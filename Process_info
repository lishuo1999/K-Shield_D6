#!/bin/python3

import subprocess
import os
import pprint

def ps_aux():
    subprocess.call('ps aux', shell=True)
    subprocess.call('ps aux > ps_aux_result.txt', shell=True)
ps_aux()


def top():
    process = os.popen('top -n 1')
    preprocessed = process.read()
    process.close()
    output = 'top_result.txt'
    fout = open(output,'w')
    fout.write(preprocessed)
    fout.close()
    print(preprocessed)
top()

#Filename:CPU1.py
#Filename:meminfo.py
from future import print_function
from collections import OrderedDict

def CPUinfo():

    CPUinfo=OrderedDict()
    procinfo=OrderedDict()
    nprocs = 0
    with open('/proc/cpuinfo') as f:
        for line in f:
            if not line.strip():
                #end of one processor
                CPUinfo['proc%s' % nprocs]=procinfo
                nprocs = nprocs+1
                #Reset
                procinfo=OrderedDict()
            else:
                if len(line.split(':')) == 2:
                    procinfo[line.split(':')[0].strip()] = line.split(':')[1].strip()
                else:
                    procinfo[line.split(':')[0].strip()] = ''
    return CPUinfo

if __name__ == '__main__':
    CPUinfo = CPUinfo()
    for processor in CPUinfo.keys():
        print('CPUinfo[{0}]={1}'.format(processor,CPUinfo[processor]['model name']))
        f = open('CPUinfo_result.txt', 'w')
        f.write('CPUinfo[{0}]={1}'.format(processor,CPUinfo[processor]['model name']))
        f.close()

def meminfo():

    meminfo = OrderedDict()
    with open('/proc/meminfo') as f:
        for line in f:
            meminfo[line.split(':')[0]] = line.split(':')[1].strip()
    return meminfo

if __name__ == '__main__':
    meminfo = meminfo()
    print("Total memory:{0}".format(meminfo['MemTotal']))
    print("Free memory:{0}".format(meminfo['MemFree']))
    f = open('meminfo_result.txt', 'w')
    f.write("Free memory:{0}".format(meminfo['MemFree']))
    f.write("Free memory:{0}".format(meminfo['MemFree']))
    f.close()
